#include<iostream>
#include<windows.h> // Подключаем три препроцессора . Один для ввода/вывода , второй для вычисления , третий для подключения консоли 
#include<math.h>
using namespace std;
const int n = 50;
int main()
{
	int   minMod, suMod,count = 0,sum=0,temp;
	system("chcp 1251"); // Задаем таблицу символов для работы с консолью
	int massiv[n]; int temps[n];
	//srand( time(0) ); //задает постоянное рандомное значение 
	for (int i = 0;  i < n;i++) // объявление массива , вывод его в консоль и поиск суммы элементов после двух 0
	{
		massiv[i] = rand()%200 - 100 ; //задаем случайное значение для элемента масива в рамках от -100 до 99
		cout << massiv[i] << "; ";
		if (massiv[i] == 0) {
			count++;
		}
		if (count >= 2)  // если два нулевых элемента было , сумируем остальные 
		{
			sum += abs(massiv[i]);
		}
	}
	cout << endl;
	minMod = abs(massiv[0]);
	for (int i = 1; i < n; i++) //поиск минимального по модулю элемента
	{
		if (minMod > abs(massiv[i])) 
		{
			minMod = abs(massiv[i]);
		}
	}
	cout << "Минимальный по модулю элемнет массива равен = " << minMod<<endl;
	cout << "Сумма элементов по модулю после 2-х нулевых = " << sum<< endl;
	int center = n / 2 ; //определяем центр массива
	int counter = 0; // переменная хранящая индекс числа
	for (int i = 0; i < n; i++)  //перенос данных согласно условию, слева то что стояло на нечетном месте , справа то что стояло на четной позиции 
	{
		if (i % 2 == 1) // если позиция не кратна двум , то ставим его в начало 
		{
			temps[counter] = massiv[i];
			counter++;
		}
		else  // если позиция кратна двум , то элементы ставим от центра 
		{
			temps[center] = massiv[i];
			center++;
		}
	}
	cout << "Массив преобрпзованый так что в  первой его половине располагаются элементы, стоявшие на нечетных позициях, а во второй половине – элементы, стоявшие на четных позициях " << endl;
	for (int i = 0; i < n; i++)
	{
		cout << temps[i] << "; ";
	}

	cout << endl << "Упорядочить каждую часть массива по возрастанию, используя алгоритм сортировки методом прямого обмена : "<< endl;
	//сортировка методом пузырька 
	center = n / 2; int j,i,tema;
	for (j = center ; j > 1; j--) //сортировка левой части 
		for (i = 0; i < j - 1; i++)// сравнение двух соседних элементов
			if (temps[i] > temps[i + 1]) {
				tema = temps[i]; // перестановка элементов
				temps[i] = temps[i + 1];
				temps[i + 1] = tema;
			}
	for (j = n; j > 1; j--) //сортировка правой части 
		for (i = center; i < j - 1; i++)// сравнение двух соседних элементов
			if (temps[i] > temps[i + 1]) {
				tema = temps[i]; // перестановка элементов
				temps[i] = temps[i + 1];
				temps[i + 1] = tema;
			}
// конец сортировки 
	for (int i = 0; i < n; i++)
	{
		cout << temps[i] << "; ";
	}
	return 0;
}

